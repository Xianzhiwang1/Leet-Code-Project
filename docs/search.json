[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "“I thought that you quit?”\n“Nah I’m quittin’ again cause I started again”\n“This like the storm before the calm, We’ll get to the vacation later.”\n–Drake"
  },
  {
    "objectID": "posts/blog-05-len-of-last-word/index.html",
    "href": "posts/blog-05-len-of-last-word/index.html",
    "title": "(Leet Code Problem 58) Length of Last Word and More Problems",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\nSome Leet Code problems\nThe source code of our implementation could be found in this directory on github along with this blog post.\n\nfrom main import *\n\n\n# problem 58 length of last word\nmystring = \"this is a big dawg   \"\nprint(f\"inverted string: {mystring[::-1]}\")\nprint(f\"length of entire string: {len(mystring)}\")\nmysoln = Solution()\nprint(f\"length of last word: {mysoln.lengthOfLastWord(mystring)}\")\n\ninverted string:    gwad gib a si siht\nlength of entire string: 21\nlength of last word: 4\n\n\n\n# problem 9 Palindrome Number\nmysoln2 = Solution()\nmyint = 115696511\nprint(mysoln2.isPalindrome(myint))\nmyint2 = 123923842\nprint(mysoln2.isPalindrome(myint2))\n\n# using the second implementation\nprint(mysoln2.isPalindromeII(myint))\nprint(mysoln2.isPalindromeII(myint2))\nmyint3 = 141\nmyint4 = 5665\nprint(mysoln2.isPalindromeII(myint3))\nprint(mysoln2.isPalindromeII(myint4))\n\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\n\n\n\n# longest common prefix\nstrs = [\"dog\", \"dogpoop\", \"dogfood\",\"dogday\"]\nstrs2 = [\"bigdawg\", \"lildawg\", \"crib\", \"whip\", \"stack\"]\nprint(f\"longest common prefix is: {mysoln2.longestCommonPrefix(strs)}\")\nprint(f\"longest common prefix is: {mysoln2.longestCommonPrefix(strs2)}\")\n\nlongest common prefix is: dog\nlongest common prefix is: \n\n\n\n# two sum\nnums = [2,7,11,15]\ntarget = 9\nprint(mysoln2.twoSum(nums, target))\nnums = [3,2,4]\ntarget = 6 \nprint(mysoln2.twoSum(nums, target))\nnums = [3,3]\ntarget = 6 \nprint(mysoln2.twoSum(nums, target))\n\n[0, 1]\n[1, 2]\n[0, 1]\n\n\n\n# 28 find index of the first occurrence in a string\nhaystack = \"sadbutsad\"\nneedle = \"sad\"\nprint(mysoln2.strStrGOOD(haystack, needle))\nhaystack = \"smilesasad\"\nneedle = \"sad\"\nprint(mysoln2.strStrGOOD(haystack, needle))\nhaystack = \"leetcode\"\nneedle = \"code\"\nprint(mysoln2.strStrGOOD(haystack, needle))\nhaystack = \"leetcode\"\nneedle = \"leeto\"\nprint(mysoln2.strStrGOOD(haystack, needle))\nhaystack = \"busbbustdown\"\nneedle = \"bust\"\nprint(mysoln2.strStrGOOD(haystack, needle))\nhaystack = \"busbbustdown\"\nneedle = \"s\"\nprint(mysoln2.strStrGOOD(haystack, needle))\nhaystack = \"mississippi\"\nneedle = \"issip\"\nprint(mysoln2.strStrGOOD(haystack, needle))\nhaystack = \"mississippi\"\nneedle = \"issipi\"\nprint(mysoln2.strStrGOOD(haystack, needle))\n\n0\n7\n4\n-1\n4\n2\n4\n-1\n\n\n\n# generate an image \nfrom matplotlib import pyplot as plt\nimport numpy as np\n# np.random.random_integers(low,high,shape)\nM = np.random.randint(0,256, (5,7,3))\n\n\n# we just want an image for our blog entry\nplt.imshow(M, interpolation='none')\n\n&lt;matplotlib.image.AxesImage at 0x7f6cec6651d0&gt;"
  },
  {
    "objectID": "posts/blog-00-example/index.html",
    "href": "posts/blog-00-example/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/blog-00-example/index.html#math",
    "href": "posts/blog-00-example/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/blog-06-sort-colors/index.html",
    "href": "posts/blog-06-sort-colors/index.html",
    "title": "(Leet Code Problem 75) Sort Colors and more Problems",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\nSome Leet Code problems\nThe source code of our implementation could be found in this directory on github along with this blog post.\n\nfrom main import *\n\n\nmysoln = Solution()\nmynum = [2,0,2,1,1,0]\nmysoln.sortColors(mynum)\n\n\nprint(f\"the sorted list is: {mynum}\")\n\nthe sorted list is: [0, 0, 1, 1, 2, 2]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "December’s Very Own blog",
    "section": "",
    "text": "(Leet Code Problem 75) Sort Colors and more Problems\n\n\n\n\n\nsolution to Leet Code problem 75 and more.\n\n\n\n\n\n\nMar 13, 2024\n\n\nShawnZ\n\n\n\n\n\n\n  \n\n\n\n\n(Leet Code Problem 58) Length of Last Word and More Problems\n\n\n\n\n\nsolution to Leet Code problem 58 and more.\n\n\n\n\n\n\nJan 14, 2024\n\n\nShawnZ\n\n\n\n\n\n\n  \n\n\n\n\n(Leet Code Problem) Add Binary Solution in Python\n\n\n\n\n\nsolution to Leet Code problem Add Binary and more.\n\n\n\n\n\n\nDec 17, 2023\n\n\nXianzhi Wang\n\n\n\n\n\n\n  \n\n\n\n\nML Final Project\n\n\n\n\n\nFinal Project on prediction of Incorporation using replication data file on Russian Historical Factory level data from Professor Gregg, Middlebury College, Vermont\n\n\n\n\n\n\nMay 2, 2023\n\n\nPrateek and Xianzhi\n\n\n\n\n\n\n  \n\n\n\n\nCompare Newton Raphson and Logistic Regression\n\n\n\n\n\nA Test of the Newton Raphson we implemented\n\n\n\n\n\n\nApr 10, 2023\n\n\nXianzhi\n\n\n\n\n\n\n  \n\n\n\n\nMy implementation of SVM from scratch\n\n\n\n\n\nLearn SVM from scratch\n\n\n\n\n\n\nApr 5, 2023\n\n\nXianzhi\n\n\n\n\n\n\n  \n\n\n\n\nHello Blog\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/blog-04-add-binary/index.html",
    "href": "posts/blog-04-add-binary/index.html",
    "title": "(Leet Code Problem) Add Binary Solution in Python",
    "section": "",
    "text": "Some Leet Code problems\nThe source code of our implementation could be found in this directory on github along with this blog post. #### Add Binary We need to take care of adding two digits together in binary, which is done mod 2, and we also need to implement the “carry” term.\n\n%load_ext autoreload\n%autoreload 2\n\n\nfrom source import *\n\n\nsoln_object = Solution()\nanswer = soln_object.addBinary(\"1010\", \"1011\")\nprint(answer)\n\nanswer = soln_object.addBinary(\"11\", \"1\")\nprint(answer)\n\nanswer = soln_object.addBinary(\"11111\", \"1\")\nprint(answer)\n\n\n\n10101\n100\n100000\n\n\nWe need to sum up the \\(2^0\\) th degit of the first number with the \\(2^0\\) th degit of the second number, then sum up the \\(2^1\\) th degit, and also have a carry term.\nWhen we sum together \\(1\\) and \\(1\\) in binary, we get \\(0\\) and carry = 1, so we need to do arithmetic mod \\(2\\) . Then we use floor divide by \\(2\\) to determine the carry term.\n\n# use mod 2 to compute the digit\nx = 1 % 2\nprint(x)\n\n1\n\n\n\n# use floor divide for the carry term\nx = 1 // 2\ny = 3 // 2\nz = 2 // 2\nprint(x)\nprint(y)\nprint(z)\n\n0\n1\n1\n\n\n\n# 88 Merge Sorted Array\nnum1 = [1,2,3,0,0,0]\nm = 3\nnum2 = [2,5,6]\nn = 3\nsoln2 = Solution()\nsoln2.merge(num1, m, num2, n)\nprint(num1)\n# another test\nnum1 = [5,5,6,7,0,0,0]\nm = 4 \nnum2 = [1,2,8]\nn = 3\nsoln2 = Solution()\nsoln2.merge(num1, m, num2, n)\nprint(num1)\n\n[1, 2, 2, 3, 5, 6]\n[1, 2, 5, 5, 6, 7, 8]\n\n\n\n# 69 Sqrt(x)\nx = 8\nprint(soln2.mySqrt(x))\nx = 11\nprint(soln2.mySqrt(x))\nx = 16\nprint(soln2.mySqrt(x))\nx = 48 \nprint(soln2.mySqrt(x))\n\n2\n3\n4\n6\n\n\n\n# 35 search insert position\nnums=[1,3,5,6]\ntarget = 5\nprint(soln2.searchInsert(nums, target))\nnums=[1,3,5,6]\ntarget = 2 \nprint(soln2.searchInsert(nums, target))\nnums=[1,3,5,6]\ntarget = 7 \nprint(soln2.searchInsert(nums, target))\nnums=[3,5,6,8,9]\ntarget = 2 \nprint(soln2.searchInsert(nums, target))\n\n2\n1\n4\n0\n\n\n\n# log(n) runtime\nnums=[1,3,5,6]\ntarget = 5\nprint(soln2.searchInsertII(nums, target))\nnums=[1,3,5,6]\ntarget = 2 \nprint(soln2.searchInsertII(nums, target))\nnums=[1,3,5,6]\ntarget = 7 \nprint(soln2.searchInsertII(nums, target))\nnums=[3,5,6,8,9]\ntarget = 2 \nprint(soln2.searchInsertII(nums, target))\n\n2\n1\n4\n0"
  },
  {
    "objectID": "posts/blog-03-ml-0451-proj/index.html",
    "href": "posts/blog-03-ml-0451-proj/index.html",
    "title": "ML Final Project",
    "section": "",
    "text": "We aim to study the history and effects of incorporation in Russia. Our project uses historical primary data from Russian factory censuses which were digitized, cleand and curated by Professor Amanda Gregg and are freely available on the American Economic Association’s website. While economic historians frequently bicker about the origins and effectiveness of corporations- most agree that the 19th century witnessed the rise of the corporate business form in Europe and North America. Firms in Russia began incorporatinng relatively late- in the late 19th century. We aim to study the factors that may lead to a firm choosing to incorporate- and to study the effects of incorporation on the firm itself. We intend to use supervised learning and feature engineering to study the variables that are the most influenced incorporation, and the variables that make incorporation more likely. We need to note that this is an unbalanced data set, in the sense that most factories are not incorporated.\nWe have used this replication data set to test our machine learning models (logistic regression, etc) and make predictions. We looked out for bias in machine learning, since our data set is unbalanced. Also, it is a historical fact that there was only a low percentage of incorporation going on in Late Imperial Russia at that time. Our data comes from (here)[https://www.aeaweb.org/articles?id=10.1257/aer.20151656], and our question is how to predict whether a factory incorporate or not in that period. Our model should be about to give predictions that are more or less consistent with the arguments presented in the published paper, “Factory Productivity and the Concession System of Incorporation in Late Imperial Russia, 1894-1908.” We focused on using supervised learning to look at how different features relate to the dependent variable, which is incorporated or not. Our main result is using logistic regression to predict if factories would incorporate or not, and our model is quite useful and agrees with our economics intuition.\nThe source code for this project could be found here. We have a README.md file that outlines what our project want to achieve, and roughly how we are going to implement the models and analysis. We also have a separate .txt file that gives a dictionary of all the variable names and their actual meaning. Hence, we encourage the reader to also reference that .txt file to remember what does each variable represent."
  },
  {
    "objectID": "posts/blog-03-ml-0451-proj/index.html#some-historical-context-about-russia-and-descriptions-about-the-russians-system-of-incorporation",
    "href": "posts/blog-03-ml-0451-proj/index.html#some-historical-context-about-russia-and-descriptions-about-the-russians-system-of-incorporation",
    "title": "ML Final Project",
    "section": "Some historical context about Russia and descriptions about the Russians system of incorporation",
    "text": "Some historical context about Russia and descriptions about the Russians system of incorporation\nSince the development of corporations in the 16th century, the legal codes allowing them to exist have been adopted by nearly all countries. Most countries, rightly, treated the idea of corporations with both excitement and apprehension. This is certainly true for Imperial Russia in the late 19th century. Russia observed the rapid advancement of Western European states such as England, Holland and Germany as a security threat. It wanted to create a system, with its limited resources, that allows for the existence corporations, while also maintaining a high degree of regulation.\nHence emerged the “Concession System of Incorporation” in Russia. Under this system, incorporation was granted in a slow, tedious and expensive manner on a case-by-case basis. The high costs and logistical challenges posed a serious barrier towards firms wishing to incorporate. Hence, under these circumstances, only some firms would benefit from incorporation, and would choose to incorporate. In this project, we wish to study the characteristics of firms that would choose to incorporate in this context. Doing so can allow us to better understand the economy of early 20th century Russia, the adoption and development of corporations, and the fundamental nature of corporations.\nOur work verifies and builds upon Professor Amanda Gregg’s work on corporations in Russia in “Factory Productivity and the Concession System of Incorporation in Late Imperial Russia, 1894–1908”"
  },
  {
    "objectID": "posts/blog-03-ml-0451-proj/index.html#data",
    "href": "posts/blog-03-ml-0451-proj/index.html#data",
    "title": "ML Final Project",
    "section": "Data",
    "text": "Data\nWe get our data from the Imperial Russian Factory Database, 1894-1908, compiled by Professor Gregg. This dataset is a digitzation of the Russian factory censuses from 1894, 1900 and 1908. This data is at the factory level, and includes information about the size of the factory’s workforce, the total power of its equipment, its revenue, and whether the firm owning it incorporated or not. It also contains information about the location of the firm and the date of its incorporation.\nWe hope to use this data to examine the types of industries that would benefit most from incorporation.\n\ninsert viz+statistics about number of factories belonging to corporations and non-corporations\ninsert visualization for number of factories by sector and ownership\ninsert visualization for factories by workforce, split by sector and by corporations/ non-corporations\ninsert visualization for factories by power used, splot by sector and corporations/ non-corporations\ninsert same by revenue\n\nFirst, let us import some libraries that will become useful down the road. Also, the following snippet will automatically reload the final_project_code.py file where we keep our functions.\n\n\nCode\n%load_ext autoreload\n%autoreload 2\n\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\n\nCode\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegression\nfrom final_project_code import FinalProject \nimport pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\nfrom itertools import combinations\nfrom matplotlib.patches import Patch\nimport seaborn as sns\nfrom mlxtend.plotting import plot_decision_regions\nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\n\n\n\nRead in the data\nLet us create an instance of the class we defined in final_project_code.py, and let us read in the entire data set.\n\n\nCode\n# from sklearn.metrics.pairwise import rbf_kernel\nFP = FinalProject()\ndf = pd.read_csv(\"./AG_Corp_Prod_DataBase.csv\", low_memory=False)\nRvss = pd.read_csv(\"./AG_Corp_Prod_DataBase.csv\", low_memory=False)\n\n\nLet us now observe some summary statistics about our dataset.\nThe following visualization demonstrates the number of corporations and non-corporations in our dataset:\n\n\nCode\ncorporation_percentage = (df['Form'].value_counts(normalize=True) * 100).loc[1]\n\nsns.barplot(x=['Corporation', 'Non-corporation'], y=[corporation_percentage, 100 - corporation_percentage])\n\n\n&lt;AxesSubplot:&gt;\n\n\n\n\n\nAs we can observe, we have significantly more factories owned by non-corporations than we do factories owned by corporations. This has the potential to impact our research methods. We will discuss this further later in the blog post. Let us also break this chart down by the type of industry.\n\n\nCode\ndf['Ownership'] = df['Form'].map({1: 'Corporation', 0: 'Non-corporation'})\ng = sns.catplot(x='Industry', hue='Ownership', data=df, kind='count', height=8, aspect=1.5)\n\n\n\n\n\nWe can already initially observe that certain industries how a high proportion of factories owned by corporations compared to other industries. For example, the metals and machines, cotton and chemical industries have a significantly higher proportion of factories being owned by incorporated firms.\nWe can also take a look at the number factories in each industry in our dataset. We observe that the food and metals industries have the greatest number of factories, while we have relatively few factories for silk and flax.\nLet us now take a look at the number of workers employed at each factory.\n\n\nCode\nsns.displot(df[\"TotalWorkers\"], kde=False, bins=50)\n#sns.histplot(df['TotalWorkers'], kde=False, color='green', log_scale=('y'))\n\n\n\n\n\nWe can see that have a large number of factories with very few workers, and very few factories with a large number of workers.\nLet us now compare this distribution with the distribution for only corporation-owned factories:\n\n\nCode\nsns.displot(df[df['Form']==1]['TotalWorkers'], kde=False, bins=50, stat='density', common_norm=False)\nplt.ylabel('Proportion')\nplt.show()\n\n\n\n\n\nAs we can see, while observe a similar trend for corporation owned factories- this distribution has a fatter tail- indicating that factories owned by corporations have more workers. Let us perform the same analysis for total power per factory:\n\n\nCode\nsns.displot(df[\"TotalPower\"], kde=False, bins=50)\n\n\n\n\n\n\n\nCode\nsns.displot(df[df['Form']==1]['TotalPower'], kde=False, bins=50, stat='density', common_norm=False)\nplt.ylabel('Proportion')\nplt.show()\n\n\n\n\n\nWe can draw similar inferences from our distribution for power: factories owned by corporations are more likely to employ a greater total power value.\nWe are interested in seeing which industry in Late Imperial Russia had high machine power (measured in horsepower) and have high number of workers. We also want to get a sense of the distribution of machine power and number of workers, and visualize them by industry. Hence, let’s focus on the picture below. We see that roughly, factory with more machine power tend to also have more workers, and most company cluster at the \\(2000\\) horse power level, and \\(2500\\) workers.\n\n\nCode\nsns.jointplot(data=df, x=\"TotalWorkers\", y = \"TotalPower\", hue=\"Industry\")\n\n\n\n\n\nSimilarly, here’s another plot to visualize the unbalanced nature of the data set. Here, Form is the desired label that we want to predict. Form taking a value of \\(1\\) means that factory was incorporated, i.e., it was owned by a incorporated firm. If Form take the value of \\(0\\), then that factory was not incorporated. In the next plot, instead of TotalPower, which stands for Total amount of horse power and TotalWorkers, which stands for total number of workers, we use logPowerperWorker and logRevperWorker as our y-axis and our x-axis. logPowerperWorker is obtained by taking the log of \\(\\frac{Power}{Worker}\\), and logRevperWorker is log of \\(\\frac{Revenue}{Worker}\\). And the hue is whether the factory is encorporated or not. Again, we see that the orange dots, which corresponds to \\(1\\), which corresponds to encorporated, is a very small percentage of all the factories. Most factories are not encorporated. Also, we observe that the data points follows a bell-shaped distribution on the two dimensions.\n\n\nCode\nsns.jointplot(data=df, x=\"logRevperWorker\", y=\"logPowerperWorker\", hue = \"Form\")"
  },
  {
    "objectID": "posts/blog-02-newton-raphson/Newton_Raphson_test.html",
    "href": "posts/blog-02-newton-raphson/Newton_Raphson_test.html",
    "title": "Compare Newton Raphson and Logistic Regression",
    "section": "",
    "text": "Test Newton Raphson and Logistic Regression\nThe source code of our implementation could be found in this directory on github along with this blog post.\n\n\nCode\n%load_ext autoreload\n%autoreload 2\n\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\n\nCode\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegression\nimport pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\nfrom itertools import combinations\nfrom matplotlib.patches import Patch\nimport seaborn as sns\n# from mlxtend.plotting import plot_decision_regions\nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics.pairwise import rbf_kernel\n\n\n\n\nCode\nfrom sklearn.datasets import make_blobs\nfrom Newton_Raphson_test import Newton_Raphson\n\n\n\n\nCode\n# create test data set\nX_train, y_train = make_blobs(n_samples=300, centers = 2, cluster_std= 2.5, n_features=2, random_state=42)\nprint(f\"shape of X_train is: {np.shape(X_train)}\")\nprint(f\"shape of y_train is: {np.shape(y_train)}\")\nprint(f\"X_train.shape[0] is: {X_train.shape[0]}\")\nprint(f\"y_train.shape[0] is: {y_train.shape[0]}\")\nprint(f\"X_train.shape[1] is: {X_train.shape[1]}\")\n\n\nshape of X_train is: (300, 2)\nshape of y_train is: (300,)\nX_train.shape[0] is: 300\ny_train.shape[0] is: 300\nX_train.shape[1] is: 2\n\n\n\n\nCode\n# plot test data set\nplt.figure(figsize=(6,6))\nplt.scatter(X_train[:,0],X_train[:,1], c=y_train)\n\n\n&lt;matplotlib.collections.PathCollection at 0x7f75715ee5d0&gt;\n\n\n\n\n\n\n\nCode\nmyNR = Newton_Raphson()\nmyNR.regress(y = y_train, X = X_train, max_iters=1e3, tol=1e-9, converged=False)\n\n\nnumber of iteration: 10\nbeta: [[ 0.88131503]\n [-0.8612759 ]\n [ 3.62857607]]\nnumber of iteration: 20\nbeta: [[ 1.05875831]\n [-1.08493095]\n [ 4.57156319]]\nnumber of iteration: 30\nbeta: [[ 1.05911467]\n [-1.08539209]\n [ 4.57354849]]\nnumber of iteration: 40\nbeta: [[ 1.05911502]\n [-1.08539254]\n [ 4.57355043]]\nConverged with 41 iterations\nThe beta we end up with is: [[ 1.05911502]\n [-1.08539254]\n [ 4.57355043]]\n\n\n\n\nCode\n# NR.big_plot(X_train, y_train, X_validate, y_validate, X_test, y_test, 30, 10)\n\n\n\n\nCode\nmyNR.bare_bone_plot(X_train, y_train, 6,6)\nprint(f\"the score of our Newton_Raphson implementation is: {myNR.score(X_train,y_train)}\")\n# print(NR.score(X_test,y_test))\n# print(NR.score(X_validate,y_validate))\n\n\nthe weight beta is: [[ 1.05911502]\n [-1.08539254]\n [ 4.57355043]]\nthe score of our Newton_Raphson implementation is: 0.9733333333333334\n\n\n\n\n\n\n\nNow, we take a look at the Newton’s Method in Logistic Regression provided to us by sklearn library.\n\n\nCode\nLR = LogisticRegression(solver=\"newton-cg\")\nLR.fit(X_train, y_train)\nLR.coef_\n\n\narray([[ 0.98557955, -1.00811845]])\n\n\n\n\nCode\n# LRscoreTest = LR.score(X_test, y_test)\n# print(LRscoreTest)\nLRscoreTrain= LR.score(X_train, y_train)\nprint(LRscoreTrain)\n\n\n0.9733333333333334\n\n\n\n\nCode\n# y_test= y_test.reshape(-1)\n# NR.simple_plot(LR, X_test, y_test, 5, 5)\n\n\n\n\nCode\nprint(LR.coef_)\na_0 = LR.coef_[0][0]\na_1 = LR.coef_[0][1]\nprint(LR.intercept_[0])\nplt.rcParams[\"figure.figsize\"] = (6,6)\nfig = plt.scatter(X_train[:,0], X_train[:,1], c = y_train)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\nf1 = np.linspace(-7.5,7.5, 501)\np = plt.plot(f1, - (LR.intercept_/a_1) - (a_0/a_1)*f1, color = \"black\")\ntitle = plt.gca().set_title(f\"score= {round(LRscoreTrain,3)} using {LR}\")\n\n\n[[ 0.98557955 -1.00811845]]\n4.250774512606014\n\n\n\n\n\nIt looks like we made it! Our implementation and the one from sklearn perform in the same way."
  },
  {
    "objectID": "posts/blog-01-svm/svm_test.html",
    "href": "posts/blog-01-svm/svm_test.html",
    "title": "My implementation of SVM from scratch",
    "section": "",
    "text": "My SVM implementation\nThe source code of this implementation could be found in this directory on github along with this blog post.\n\n\nCode\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\n# from final_project_code import FinalProject \n# from newton_raphson import Newton_Raphson\n# from final_plot import plot_stuff\nfrom sklearn.datasets import make_moons\nfrom main import supp_vec_machine\n\n\n\n\nCode\n%load_ext autoreload\n%autoreload 2\n\n\n\n\nCode\nfrom sklearn.preprocessing import LabelEncoder\nfrom itertools import combinations\nfrom matplotlib.patches import Patch\n# import seaborn as sns\n# from mlxtend.plotting import plot_decision_regions\n\n\n\n\nCode\n# mySVC = SVC(kernel=\"linear\", gamma=\"auto\", shrinking=False)\n# mySVC.fit(X_test, y_test)\n\n\n\n\nCode\n# mysvm = supp_vec_machine(row_length=row_length)\n# mysvm.fit(X_test,y_test, max_iter=1e3, alpha=1, tol=1e-5, lamb=0.5)\n\n\n\n\nCode\n# print(mysvm.weights)\n# print(mysvm.beta)\n\n\n\n\nCode\n# mysvm.big_plot(X_train, y_train, X_validate, y_validate, X_test, y_test, 9,3)\n\n\n\n\nCode\nX,y= make_moons(100, shuffle=True, noise = 0.2)\nX_train, y_train = make_moons(100, shuffle=True, noise = 0.28)\nX_validate, y_validate= make_moons(100, shuffle=True, noise = 0.30)\nX_test, y_test= make_moons(100, shuffle=True, noise = 0.32)\nplt.rcParams[\"figure.figsize\"] = (4,4)\nplt.scatter(X[:,0], X[:,1], c=y)\nlabels=plt.gca().set(xlabel=\"Feature 1\", ylabel=\"Feature 2\")\n\n\n\n\n\n\n\nCode\nsoln = SVC(kernel=\"linear\", gamma=\"auto\", shrinking=False)\nsoln.fit(X_train, y_train)\n\n\nSVC(gamma='auto', kernel='linear', shrinking=False)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SVCSVC(gamma='auto', kernel='linear', shrinking=False)\n\n\n\n\nCode\nprint(soln.coef_)\nprint(soln.intercept_)\n\n\n[[ 0.81155736 -2.0784927 ]]\n[0.25771612]\n\n\n\n\nCode\nprint(soln.coef_)\na_0 = soln.coef_[0][0]\na_1 = soln.coef_[0][1]\nprint(soln.intercept_[0])\nplt.rcParams[\"figure.figsize\"] = (6,6)\nfig = plt.scatter(X_train[:,0], X_train[:,1], c = y_train)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\nf1 = np.linspace(-1.5,3.5, 501)\np = plt.plot(f1, - (soln.intercept_/a_1) - (a_0/a_1)*f1, color = \"black\")\ntitle = plt.gca().set_title(f\"SVM using {soln}\")\n\n\n[[ 0.81155736 -2.0784927 ]]\n0.25771611779909764\n\n\n\n\n\n\n\nCode\nmysvm = supp_vec_machine()\nmysvm.fit(X_train, y_train, max_iter=1e5, alpha=1, tol=1e-6, lamb=0.5)\n\n\niter_count: 500\niter_count: 1000\niter_count: 1500\niter_count: 2000\niter_count: 2500\niter_count: 3000\niter_count: 3500\niter_count: 4000\niter_count: 4500\niter_count: 5000\niter_count: 5500\niter_count: 6000\nConverged with 6490 iterations\nThe weights we end up with is: [[ 0.27680122]\n [-0.0586523 ]\n [ 0.60432424]]\n\n\n\n\nCode\n# our implementation\nmysvm.big_plot(X_train, y_train, X_validate, y_validate, X_test, y_test, 9,3)\n\n\n\n\n\n\n\nSecond Take\nOur first implementation seems off, let us do it all over again from scratch."
  }
]