[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "Final Project on prediction of Incorporation using replication data file on Russian Historical Factory level data from Professor Gregg, Middlebury College, Vermont\n\n\n\n\n\n\nMay 2, 2023\n\n\nPrateek and Xianzhi\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/final-blog-post/index.html",
    "href": "posts/final-blog-post/index.html",
    "title": "ML Final Project",
    "section": "",
    "text": "The source code for this project could be found here. We have a README.md file that outlines what our project want to achieve, and roughly how we are going to implement the models and analysis. We also have a separate .txt file that gives a dictionary of all the variable names and their actual meaning. Hence, we encourage the reader to also reference that .txt file to remember which variable means what."
  },
  {
    "objectID": "posts/final-blog-post/index.html#data",
    "href": "posts/final-blog-post/index.html#data",
    "title": "ML Final Project",
    "section": "Data",
    "text": "Data\n\nWhere the data comes from\n\nThe Russian factory censuses from 1894, 1900 and 1908\n\nWhat the data includes\n\nThe data is factory level and includes the following information:\n\nWhat we’re hoping to do with the data\nSome summary statistics\n\nFirst, let us import some libraries that will become useful down the road. Also, the following snippet will automatically reload the final_project_code.py file where we keep our functions.\n\n%load_ext autoreload\n%autoreload 2\n\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegression\nfrom final_project_code import FinalProject \n\n\nimport pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\nfrom itertools import combinations\nfrom matplotlib.patches import Patch\nimport seaborn as sns\nfrom mlxtend.plotting import plot_decision_regions\n\n\nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score\n\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import classification_report\n\n\nRead in the data\nLet us create an instance of the class we defined in final_project_code.py, and let us read in the entire data set.\n\nFP = FinalProject()\n\n\nRvss = pd.read_csv(\"./AG_Corp_Prod_DataBase.csv\")\n\n/tmp/ipykernel_23326/139095848.py:1: DtypeWarning: Columns (3,13) have mixed types. Specify dtype option on import or set low_memory=False.\n  Rvss = pd.read_csv(\"./AG_Corp_Prod_DataBase.csv\")\n\n\nFirst, let’s do some data visualization. We are interested in seeing which industry in Late Imperial Russia had high machine power (measured in horsepower) and have high number of workers. We also want to get a sense of the distribution of machine power and number of workers, and visualize them by industry. Hence, let’s focus on the picture below. We see that roughly, factory with more machine power tend to also have more workers, and most company cluster at the \\(2000\\) horse power level, and \\(2500\\) workers.\n\nsns.jointplot(data=Rvss, x=\"TotalWorkers\", y = \"TotalPower\", hue=\"Industry\")\n\n<seaborn.axisgrid.JointGrid at 0x7f850285fc70>\n\n\n\n\n\nSimilarly, here’s another plot to visualize the unbalanced nature of the data set. Here, Form is the desired label that we want to predict. Form taking a value of \\(1\\) means that factory was incorporated, i.e., it was owned by a incorporated firm. If Form take the value of \\(0\\), then that factory was not incorporated. In the next plot, instead of TotalPower, which stands for Total amount of horse power and TotalWorkers, which stands for total number of workers, we use logPowerperWorker and logRevperWorker as our y-axis and our x-axis. logPowerperWorker is obtained by taking the log of \\(\\frac{Power}{Worker}\\), and logRevperWorker is log of \\(\\frac{Revenue}{Worker}\\). And the hue is whether the factory is encorporated or not. Again, we see that the orange dots, which corresponds to \\(1\\), which corresponds to encorporated, is a very small percentage of all the factories. Most factories are not encorporated. Also, we observe that the data points follows a bell-shaped distribution on the two dimensions.\n\nsns.jointplot(data=Rvss, x=\"logRevperWorker\", y=\"logPowerperWorker\", hue = \"Form\")\n\n<seaborn.axisgrid.JointGrid at 0x7f8501ed73a0>\n\n\n\n\n\n\n\nPredicting whether Russian Factories want to incorporate or not\n\n\nFirst approach, rebalance the data set by random sampling\nWe start our analysis by using logistic regression to predict what kind of firms in late Imperial Russia is more likely owned by a corporation. Since our data is not balanced, we use several different approach to this problem and try them one at a time. Luckily for us, classification problem with unbalanced data labels is quite common, so we have many approaches at our disposal.\nLet us first get out definitions straight. Unbalanced data refers to those datasets where the target label has an uneven distribution of observations, First, we try to randomly sample the majority data set, which in this case, is when the label equals unincorporated. Then we keep all the data entries of the minority data set, and add in the randomly sampled extract of the majority data set with size equal to the minority data set. Then we perform logistic regression on this new data set. The good news is that our new data set is balanced, and the bad news is that we loose a lot of information by discarding many data entries in the majority data set.\nWhether to incorporate or not is an interesting question for factories and firms in late Imperial Russia. There were many factors that might affect a firm’s decision to incorporate or not, including the overall size of the factory, which could be seen in features such as total machine power of the factory and the total number of workers in a factory. Other factors such as the geographical location of the factory (i.e. which region it was located in) could also play a role. Since the decision to incorporate could be affected by many features, we see that some feature engineering could be beneficial for our analysis.\nWe download the replication data set and put it in the same directory as our project. After we read in the data, we notice that there are \\(66\\) columns, which means potentially we could have around \\(60\\) features for our machine learning model. However, let’s start small. Hence, we begin our analysis using a subset of the columns. Also, since in the original data set, there’s only a small percentage of factories that are incorporated, which is because of historical reasons in Late Imperial Russia during 1894 to 1908. For the purpose of this machine learning project, we artificially select a subset of the whole data set so that we have equal number of factories owned by incorporated firms and not incorporated firms alike.\n\nRvss.loc[Rvss['Form']==0]\n\n\n\n\n\n  \n    \n      \n      Unnamed: 0\n      id\n      Form\n      PSZ\n      PSZ1900\n      FoundingYear\n      Province\n      Region\n      Industry\n      OntheSide\n      ...\n      Animal\n      Wool\n      Cotton\n      MixedMaterials\n      Wood\n      Paper\n      MetalsandMachines\n      Foods\n      Chemical\n      Mineral\n    \n  \n  \n    \n      0\n      0\n      4156\n      0\n      NaN\n      NaN\n      1860.0\n      30\n      CentralIndustrial\n      Paper\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      1\n      1\n      52010\n      0\n      NaN\n      NaN\n      NaN\n      51\n      Previslitskii\n      Foods A\n      NaN\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      1.0\n      0.0\n      0.0\n    \n    \n      2\n      2\n      30937\n      0\n      NaN\n      NaN\n      NaN\n      41\n      CentralBlacksoil\n      Foods A\n      NaN\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      1.0\n      0.0\n      0.0\n    \n    \n      3\n      3\n      39923\n      0\n      NaN\n      NaN\n      NaN\n      3\n      Caucasus\n      Metals and Machines\n      NaN\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      1.0\n      0.0\n      0.0\n      0.0\n    \n    \n      4\n      4\n      3296\n      0\n      NaN\n      NaN\n      1882.0\n      11\n      Northwestern\n      Chemicals\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      37964\n      37964\n      34420\n      0\n      NaN\n      NaN\n      NaN\n      30\n      CentralIndustrial\n      Mineral Products\n      NaN\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      1.0\n    \n    \n      37965\n      37965\n      34210\n      0\n      NaN\n      NaN\n      NaN\n      19\n      CentralIndustrial\n      Mineral Products\n      NaN\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      1.0\n    \n    \n      37966\n      37966\n      52603\n      0\n      NaN\n      NaN\n      NaN\n      17\n      Southern\n      Foods A\n      NaN\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      1.0\n      0.0\n      0.0\n    \n    \n      37967\n      37967\n      4886\n      0\n      NaN\n      NaN\n      NaN\n      61\n      CentralIndustrial\n      Mineral Products\n      0.0\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      37968\n      37968\n      37189\n      0\n      NaN\n      NaN\n      NaN\n      8\n      Caucasus\n      Silk\n      NaN\n      ...\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n37895 rows × 66 columns\n\n\n\n\ndf = Rvss[['id', 'Form', 'FoundingYear',\n       'Province', 'Region', 'Industry', 'OntheSide', 'Age', 'TaxedActivity',\n       'YEAR', 'SubindustryCode', 'STCAP', 'Revenue',\n       'TotalWorkers', 'TotalPower', 'GrandTotalWorkers', 'RevperWorker',\n       'PowerperWorker', 'RevperGrandWorker', 'PowerperGrandWorker',\n       'logRevperWorker', 'logPowerperWorker', 'logRevperGrandWorker',\n       'logPowerperGrandWorker', 'logRev', 'logWorkers', 'logPower',\n       'RegIndGroup', 'RegIndYearGroup', 'ProvIndGroup', 'ProvIndYearGroup',\n       'IndYearGroup', 'IndustryFactor', 'ProvinceFactor', 'YearFactor',\n       'AKTS', 'PAI', 'factory_id', 'FormNextYear', 'FormNextNextYear',\n       'FactoryisCorpin1894', 'FormNextYearin1894', 'FactoryisCorpin1900',\n       'FormNextYearin1900', 'FactoryisCorpin1908', 'NEWDEV', 'SHARES',\n       'STPRICE', 'BONDS', 'Silk', 'Flax', 'Animal', 'Wool', 'Cotton',\n       'MixedMaterials', 'Wood', 'Paper', 'MetalsandMachines', 'Foods',\n       'Chemical', 'Mineral']]\n\n\nresult = FP.create_balanced_data(df)\n\ndf incorporated have 2393 many rows\nafter balancing, df not incorporated have 2393 many rows\n\n\n\nresult['Form'].mean()\n\n0.5\n\n\n\ncompression_opts = dict(method='zip', archive_name='artificially_balanced_Rvssian_Factory.csv')\nresult.to_csv('artificially_balanced_Rvssian_Factory.zip', index = False, compression=compression_opts)\n\n\nFP = FinalProject()\ntrain, validate, test = FP.split_data(result)\n\n\ndf_train, X_train, y_train = FP.prepare_data(train)\ndf_validate, X_validate, y_validate= FP.prepare_data(validate)\ndf_test, X_test, y_test = FP.prepare_data(test)"
  }
]